## 杂项函数
### 1. pack 将数据打包程二进制字符串
#### 1.1 说明
格式:
```
pack ( string $format [, mixed $args [, mixed $... ]] ) : string
```
将数据打包程二进制字符串

#### 1.2 参数
- format 格式,该参数后面跟一个可选的重复参数,重复参数可以是一个整数值或者*值来重复到输入数据的末尾.
    - 对于a,A,h,H格式化代码,其后的重复参数制定了给定数据会被使用几个字符串;
    - 对于@,其后的数字表示防止剩余数据的绝对定位(之前的数据将会被空字符串填充);
    - 对于其他格式,重复数量指定消耗多少数据并将其打包到生成的二进制字符串中.


具体格式参数如下:

Code|	Description
---|---
a|	以NUL字节填充字符串空白
A|	以SPACE(空格)填充字符串
h|	十六进制字符串，低位在前
H|	十六进制字符串，高位在前
c|	有符号字符
C|	无符号字符
s|	有符号短整型(16位，主机字节序)
S|	无符号短整型(16位，主机字节序)
n|	无符号短整型(16位，大端字节序)
v|	无符号短整型(16位，小端字节序)
i|	有符号整型(机器相关大小字节序)
I|	无符号整型(机器相关大小字节序)
l|	有符号长整型(32位，主机字节序)
L|	无符号长整型(32位，主机字节序)
N|	无符号长整型(32位，大端字节序)
V|	无符号长整型(32位，小端字节序)
q|	有符号长长整型(64位，主机字节序)
Q|	无符号长长整型(64位，主机字节序)
J|	无符号长长整型(64位，大端字节序)
P|	无符号长长整型(64位，小端字节序)
f|	单精度浮点型(机器相关大小)
d|	双精度浮点型(机器相关大小)
x|	NUL字节
X|	回退一字节
Z|	以NUL字节填充字符串空白(new in PHP 5.5)
@|	NUL填充到绝对位置

#### 1.3 返回值
返回包含数据的二进制字符串.

#### 1.4 引申
##### 1.4.1 字节序
字节序即多字节数据的存放顺序.
比如:字符A,B的ASCII码的二进制表示为0100 0001,0100 0010(对应十进制65,66,十六进制0x41,0x42),对于存储字符串AB,我们可以0x41 0x42也可以0x42 0x41,这个顺序就是字节序.

##### 1.4.2 高/低位字节
比如字符串AB,左高右低(正常的阅读顺序),A为高字节,B为低字节.

##### 1.4.3 高/低地址
假设0x123456是按从高位到底位的顺序储存，内存中是这样存放的：
```
高地址 -> 低地址
12 -> 34 -> 56
```

##### 1.4.4 大端字节序(网络字节序)
大端就是将高位字节放到内存的低地址端,低位字节放到高地址端.
网络传输中(如:TCP/IP)低地址端(高位字节)放在流的开始.
eg: 对于2个字节的字符串AB,传输顺序为:A(0~7bit),B(8~15bit)

小端字节序与大端相反.

##### 1.4.5 主机字节序
表示当前机器的字节序,一般为小端字节序.

#### 1.5 示例
##### 1.5.1 a打包字符串(null填充)
```
$string = pack('a6', 'china');
var_dump($string);
echo ord($string[5]);
```

测试结果:
```
string(6) "china\000"
0
```

其中ASCII码中0对应的就是null.

##### 1.5.2 A打包字符串(空格填充)
```
$string = pack('A6', 'china');
var_dump($string);
echo ord($string[5]);
```
测试结果:
```
string(6) "china "
32
```
其中ASCII码的32对应的就是空格.

##### 1.5.3 h打包
h打包是将对应的参数看作十六进制字符打包,低位在前.\
```
$string = pack('h3', 281);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);
```
测试结果:
```
string(2) "�"
array (
  0 => 130,
  1 => 1,
)
```
说明:
此处参数为281,打包前会将281转换为十六进制0x281,4位二进制数对应1位十六进制,因此将其低位补0,补齐十六进制形式,补0后为0x2810.
h格式,为低位在前,因此打印结果应该为:0x82,0x01

查看ASCII码表,0x82为十进制的130,对应的字符码为:无对应的字符,而0x01的十进制为1,对应的字符码为:soh,为非打印字符,因此是不可见的.


##### 1.5.4 H打包
H打包是将对应的参数看作十六进制字符打包, 高位在前.

```
<?php

$string = pack('H3', 281);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);
```
测试结果:
```
string(2) "("
array (
  0 => 40,
  1 => 16,
)
```

说明:
此处参数为281,打包前会将281转换为十六进制0x281,4位二进制数对应1位十六进制,因此将其低位补0,补齐十六进制形式,补0后为0x2810.
H格式,为高位在前,因此从打印结果可看出,字节序不变,打印结果为0x28,0x10

查看ASCII码表,0x28为十进制的40,对应的字符码为:(,而0x10的十进制为16,对应的字符码为:dle,为非打印字符,因此是不可见的.

##### 1.4.5 c打包
```
$format = 'c3';

$string = pack($format, 67, 68, -1);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);
```
测试结果:
```
string(3) "CD�"
array (
  0 => 67,
  1 => 68,
  2 => 255,
)
```
说明:
ord获取字符的ASCII码范围万恶哦0~255,而-1对应的字符码以补码的方式输出,即255(补码=取反+1).

##### 1.4.6 整型相关
所有的整型类型使用方法完全一样，只需要注意它们的位和字节序就可以了.

- L示例:
```
<?php

$format = 'L';

$string = pack($format, 123456789);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);
```
测试结果:
```
string(4) "�["
array (
  0 => 21,
  1 => 205,
  2 => 91,
  3 => 7,
)
```
说明:
L格式:无符号长整型(32位，主机字节序)
123456789以十六进制表示:0x75BCD15(十六进制表示比2进制表示更加简洁清晰,1位十六进制数表示4位二进制数),由于不足32位,补全后为0x075BCD15,主机字节序(一般为小端字节序,本测试机即为小端字节序),
因此打印结果为21 205 91 7

- N示例:
```
<?php

$format = 'N';

$string = pack($format, 123456789);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);
```
测试结果:
```
string(4) "[�"
array (
  0 => 7,
  1 => 91,
  2 => 205,
  3 => 21,
)
```
说明:
N格式:无符号长整型(32位，大端字节序)
123456789以十六进制表示:0x75BCD15(十六进制表示比2进制表示更加简洁清晰,1位十六进制数表示4位二进制数),由于不足32位,补全后为0x075BCD15,大端字节序(高位字节放在低地址端).
因此打印结果为7 91 205 21

- 可见大端字节序与小端字节序顺序刚好相反.

##### 1.4.7 f和d
- f示例
```
<?php

$format = 'f';

$string = pack($format, 12345.123);
var_dump($string);

$order = array();
for ($i = 0; $i < strlen($string); $i++) {
    $order[] = ord($string[$i]);
}

var_export($order);


var_dump(unpack('f', $string));
```
测试结果:
```
string(4) "~�@F"
array (
  0 => 126,
  1 => 228,
  2 => 64,
  3 => 70,
)
array(1) {
  [1] =>
  double(12345.123046875)
}
```


###### 1.4.7.1 浮点数转二进制
现代计算机中，一般都以IEEE 754标准存储浮点数，这个标准的在内存中存储的形式为：

 数符|阶码(含阶符)|尾数
---|---|---
sign|exponent|fraction

对于不同长度的浮点数,阶码与小数位分配的数量不一样,如下:

 |数符|阶码|尾数|总位数|偏移值
---|---|---|---|---|---
短实数|1|8|23|32|127
长实数|1|11|52|64|1023
临时实数|1|15|64|80|16383

以下为12345.123的二进制转化方法:
- 1. 将浮点数分别把整数部分和小数部分转换成2进制
    - 整数部分:除2取余,计算结果为:0x3039(0011 0000 0011 1001)
    - 小数部分:乘2取整,计算结果为:0001 1111 0111...(浮点数小数部分可以一直计算下去,因此才会涉及到浮点数精度.)
        ```
        0.123 * 2 = 0.246   0
        0.246 * 2 = 0.492   0
        0.492 * 2 = 0.984   0
        0.984 * 2 = 1.968   1
        0.968 * 2 = 1.936   1
        0.936 * 2 = 1.872   1
        0.872 * 2 = 1.744   1
        0.744 * 2 = 1.488   1
        0.488 * 2 = 0.976   0
        0.976 * 2 = 1.952   1
        0.952 * 2 = 1.904   1
        0.904 * 2 = 1.808   1
        ...
        ```
    - 合起来就是:0011 0000 0011 1001.0001 1111 0111...
    - 转换成二进制的浮点数,即将小数点移动到整数位只有1,结果为:1.1 0000 0011 1001 0001 1111 0111... * (2^1101), 其中1101为二进制,左移了13位,所以是1101.
- 2. 计算数符,阶码,尾数.
    - 数符:由于该浮点数时正数,故为0(负数为1)
    - 阶码:
    ```
    计算公式:阶数+偏移量
    ```
    阶码计算为:1101 + 0111 1111 = 1000 1100
    - 将结果填入32位格式中:

   sign|exponent|fraction
   ---|---|---
   0|10001100|1000 0001 1100 1000 1111 101
 - 3. 对比计算结果
    将结果化简为十六进制方便查看
    0100 0110 0100 0000 1110 0100 0111 1101 = 0x4640E47D
    按字节划分,其十进制结果为: 70 64 228 125

 - 4. 结果与计算机运行结果不一致,查资料了解到这涉及到浮点数的舍入问题.
 浮点数舍入规则为:
    - 首先是向最近的有效数舍入
    - 如果它与相邻的有效数距离一样时(即他是中间数,halfway),那么舍入到最近的偶数有效数.

 示例:
    以二进制为例,假定有效数位为4,那舍入举例如下:
- a. 1.001 001舍入结果为1.001. 原因如下,显然与前者近.
```
若采用舍去方式:1.001 001到1.001的距离为0.000 011
若采用入上方式:1.001 001到1.010的距离为0.000 1
```

- b. 1.001 101舍入结果为1.010,原因如下,显然与后者近.

```
若采用舍去方式:1.001 101到1.001的距离为0.000 101
若采用入上方式:1.001 101到1.010的距离为0.000 010
```

- c.特殊情况,有效位后一位为1,后面数位全是零,此种情况是向最近的偶数舍入
```
1.001 100 ： 它相近两个偶数分别是 1.000和1.010，显然是1.010离它近一些，故舍入到1.010
1.100 100 : 它相近两个偶数分别是 1.100和1.110，显然是1.100离它近一些，故舍入到1.100
```

规律: 如果将被舍入的值刚好等于一半,如果最低有效位奇数,,则向上舍入,如果为偶数,则向下舍入.

总结:如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），Roundings to nearest even舍入规则就是：
- 如果DD..D < 10..0，则向下舍入
- 如果DD..D > 10..0，则向上舍入
- 如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：
    - a. 如果RR..R = XX..0 （X表示任意值，0或1)，则向下舍入
    - b. 如果RR..R = XX..1，则向上舍入



回到本示例中,1 0000 0011 1001 0001 1111 0111...保留23位,且有效位后数据为11.. > 1000..的情况,因此采用向上舍入,即最终计算得尾数部分的值为:1 0000 0011 1001 0001 1111 10

最终结果为:0x4640E7E,与运行结果一致.

将0x4640E7E反过来计算求得浮点数为12345.123046875.

##### 1.4.8 x,X,Z,@
- x格式
```
<?php

$string = pack('x');
echo ord($string);
```
测试结果:
```
0
```
说明:打包一个null字符串

- X
没找到对应的示例,暂时不理解

- Z
```
<?php

$string = pack('Z2', 'abc5'); //其实就是将从Z后面的数字位置开始，全部设置为nul
var_dump($string); //输出:string(2) "a"

for($i=0;$i<strlen($string);$i++) {
    echo ord($string[$i]) . PHP_EOL;
}
//输出: 97 0
```

测试结果:
```
string(2) "a\000"
97
0
```
说明:Z格式,使用null填充字符串

- @格式
```
<?php

$string = pack('@4'); //我理解为填充N个nul
var_dump($string); //输出: string(4) ""

for($i=0;$i<strlen($string);$i++) {
    echo ord($string[$i]) . PHP_EOL;
}
```
测试结果:
```
string(4) "\000\000\000\000"
0
0
0
0
```




---
#### 参考资料
1. [pack](https://www.php.net/manual/zh/function.pack.php)
2. [PHP中pack、unpack的详细用法](https://segmentfault.com/a/1190000008305573?utm_source=tag-newest)
3. [浮点数的二进制表示方法](https://blog.csdn.net/weixin_42538437/article/details/82380210)
4. [浮点数的二进制表示(IEEE 754标准)](https://blog.csdn.net/fwb330198372/article/details/70238982)
5. [IEEE754规范的舍入方案怎么理解呢？]( https://www.zhihu.com/question/68131179/answer/273788172)

