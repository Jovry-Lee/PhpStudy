### 1 引入
#### 1.2 相关概念
###### 1.2.1 用户空间/内核空间
操作系统的核心是内核，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核，保证内核安全，操作系统将虚拟空间划分为：
- 内核空间：针对32位的Linux操作系统，将最高的1G字节空间供内核使用；
- 用户空间：针对32位的Linux操作系统，将较低的3G字节空间供用户使用；

###### 1.2.2 进程切换过程
- ①、保存处理器上下文，包括程序计数器、其他寄存器；
- ②、更新PCB信息；
- ③、将进程PCB移入相应的队列，如就绪队列、某事件的阻塞队列；
- ④、更新待执行进程的PCB；
- ⑤、更新内存管理的数据结构；
- ⑥、恢复处理器上下文。

###### 1.2.3 进程的阻塞
进程的阻塞是进程自身的一种主动行为，因此只有运行态的进程，才可进入阻塞状态。  
（当进程进入阻塞状态，是不占用cpu资源的）

###### 1.2.4 文件描述符
文件描述符是一个用于描述文件的引用的抽象化的概念。  
文件描述符形式上是一个非负的整数。实际上它是一个指向每个进程所维护的文件记录表的索引。  
（注：文件描述符仅适用于*nix操作系统）

###### 1.2.5 缓存IO（标准IO）
Linux的缓存IO机制中，操作系统会将IO数据缓存在文件系统的页缓存中（page cache）中，即数据会先被拷贝到操作系统的内核的缓冲区中，探后再从内核缓冲区中拷贝到应用程序的地址空间。
例如：当一个read操作发生时，它会经历两个阶段
- 等待数据准备好；
- 将数据从内核态拷贝到进程中。

缺点：数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

### 2 IO网络模型
由于标准IO的缺点，Linux系统产生了以下5种网络模型方案：
- 阻塞IO（Blocking IO）
- 非阻塞IO（Non-blocking IO）
- IO多路复用（IO Multiplexing）（事件驱动IO）
- 信号驱动IO（不常用）
- 异步IO（Asynchronous IO）

#### 2.1 阻塞IO
实际上，Linux系统中默认情况下所有的socket都是阻塞的。  
一个典型的read操作流程如下（阻塞IO在IO执行的两个阶段都会被阻塞）：
![阻塞IO模型](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/IO网络模型/阻塞IO模型.png)

#### 2.2 非阻塞IO
Linux中，通过设置socket将其变为非阻塞。
一个典型的read操作流程如下（非阻塞IO需要不断询问kernel数据准备好没有）：
![非阻塞IO模型](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/IO网络模型/非阻塞IO模型.png)

#### 2.3 IO多路复用
IO多路复用，也称为事件驱动IO，其优点在于单个进程可以同时处理多个网络IO。
一个select读的典型操作流程：
![IO多路复用模型](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/IO网络模型/IO多路复用模型.png)

实际上，IO多路复用的流程与阻塞IO的流程几乎一致，在连接数不是很高的情况下，使用IO多路复用可能性能还会更差一些，因为这里涉及到了两个系统调用（select和recvfrom），而阻塞IO只调用了一个。

IO多路复用的机制：
- select
- poll
- epoll

#### 2.4 异步IO
异步IO的流程如下：
![异步IO模型](https://cdn.jsdelivr.net/gh/Jovry-Lee/cdn/img/IO网络模型/异步IO模型.png)

#### 3 区别总结
##### 3.1 阻塞/非阻塞IO的区别？
顾名思义，阻塞IO会一直阻塞直到操作完成；而非阻塞IO会在数据未准备好的情况下立刻返回。
##### 3.2 同步/非同步IO的区别？
- 同步IO：同步IO操作将导致请求进程阻塞，直到IO操作完成；（注：阻塞IO、非阻塞IO、IO多路复用都属于同步IO）
- 异步IO：异步IO操作不会导致请求进程被阻塞;

非阻塞IO虽然在等待数据准备好这个阶段是非阻塞的，但是在数据准备好后，将数据从内核态拷贝到进程中这个过程中进程是阻塞的。












